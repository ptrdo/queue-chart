<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Instances</title>
  <link rel="icon" href="data:,">
  <style>
    main {
      padding: 3rem;
      text-align: center;
    }
    main input[type=button] {
      display: block;
      width: 8rem;
      margin: 1em auto;
      padding: 0.5em;
      font-size: large;
      font-variant: all-small-caps;
      -webkit-appearance: button;
    }
    main form output {
      display: inline-block;
      margin: 0 auto;
      padding: 1rem;
      font-family: monospace;
      font-size: larger;
      text-align: left;
      white-space: pre;
      color: #0072a2;
      border-bottom: 1px dotted orange;
    }
    main form fieldset {
      position: absolute;
      right: 3rem;
      top: 3rem;
      border: none;
    }
    .box-plot > hr {
      display: inline-block;
      position: absolute;
      width: 40rem;
      margin: 2rem -20rem;
      border: none; 
      border-top: 1px dotted orange;
    }
    .box-plot section {
      display: flex;
      width: 40rem;
      height: 4rem;
      margin: 1rem auto;
      flex-direction: row;
      flex-wrap: nowrap;
      justify-content: center;
      align-items: stretch;
    }
    .box-plot section article {
      border-width: 0 1px;
      border-style: solid;
      border-color: orange;
      flex-grow: 1;
    }
    .box-plot section article.internal {
      border-width: 2px 1px;
      background-color: yellow;
      z-index: 1;
    }
    .box-plot section article.internal > ins {
      display: inline-block;
      width: 1px;
      height: 3.9rem;
      background-color: #0072a2;
    }
  </style>
</head>
<body>
<main role="main" id="main">
  <article>
    <section>
      <form>
        <figure class="box-plot">
          <hr/>
          <section>
            <article class="lower outlier"></article>
            <article class="lower quartile"></article>
            <article class="internal quartile">
              <ins class="median"/>
            </article>
            <article class="upper quartile"></article>
            <article class="upper outlier"></article>
          </section>
        </figure>
        <output>0</output>
        <fieldset>
          <input type="button" name="restart" value="(re)starter" title="load JSON of Experiment data, or reset all">
          <input type="button" name="traverse" value="traverse(50)" title="ingest ~3 Simulations of data" disabled>
        </fieldset>
      </form>
    </section>
  </article>
</main>
<script>

  const collection = {

    summary: {},

    output: {},

    traverseCursor: 0,
    traverse: function (iterate=50) {

      // will need to exempt fails, cancels
      
      let i = 0;
      for (cursor = this.traverseCursor; i < iterate; i++) {
        let sim,job,startDate,endDate,elapsed = 0;
        if (cursor+i<this.output["Simulations"].length) {
          try {
            sim = this.output["Simulations"][cursor+i];
            job = sim["HPCJobs"][sim["HPCJobs"].length-1];
            startDate = new Date(Date.parse(job["StartTime"]));
            endDate = new Date(Date.parse(job["EndTime"]));
            elapsed = endDate-startDate;

          } catch (e) {
            console.error("traverse error:",e);
          }
          if (!!elapsed) {
            this.summary[sim["Id"]] = elapsed;
          }
        } else {
          document.querySelector("input[name=traverse]").setAttribute("disabled", true);
          break;
        }
      }

      this.traverseCursor += i;
      return i > 0; // there is a change
    },

    prep: function (data) {
      return data;
    },

    update: function (data) {
      this.output = this.prep(data);
      return this.output;
    },

    mean: function () {
      const values = Object.values(this.summary);
      const reducer = (accumulator, currentValue) => accumulator + currentValue;
      return Math.round(values.reduce(reducer)/values.length);
    },

    median: function () {
      const values = Object.values(this.summary)||[];
      const mid = Math.floor(values.length / 2);
      const nums = [...values].sort((a, b) => a - b);
      return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
    },
    
    outliers: function(Q1, IQR, Q3) {
      let result = {lower:{},upper:{}};
      let factor = 1.5; // 1.5 is convention
      const min = Q1 - (factor*IQR);
      const max = Q3 + (factor*IQR);
      console.log("outliers", min,  max);
      for (let sim in this.summary) {
        if (this.summary[sim] < min) {
          result.lower[sim] = this.summary[sim];
        } else if (this.summary[sim] > max) {
          result.upper[sim] = this.summary[sim];
        } 
      }
      return result;
    },

    statistics: function(data) {
      
      /* http://www.code-in-javascript.com/statistics-in-javascript/ */
      /* with minor adjustments */
      
      let result = {};
      let sum_of_squares = 0;
      let lower_quartile_index_1;
      let lower_quartile_index_2;
      
      const is_even = function (n) {
        return n % 2 == 0;
      };

      // data needs to be sorted for median etc
      data = data.sort(function(a, b){return a - b});

      // count is just the size of the data set
      result.count = data.length;

      // initialize total to 0, and then iterate data
      // calculating total and sum of squares
      result.total = 0;
      for(let i = 0; i < result.count; i++) {
        result.total += data[i];
        sum_of_squares += Math.pow(data[i], 2);
      }

      // the arithmetic mean is simply the total divided by the count
      result.arithmetic_mean = result.total / result.count;

      // method of calculating median and quartiles is different for odd and even count
      if(is_even(result.count)) {
        result.median = (data[((result.count) / 2) - 1] + data[result.count / 2]) / 2;

        // even / even
        if (is_even(result.count / 2)) {
          lower_quartile_index_1 = (result.count / 2) / 2;
          lower_quartile_index_2 = lower_quartile_index_1 - 1;

          result.lower_quartile = (data[lower_quartile_index_1] + data[lower_quartile_index_2]) / 2;
          result.upper_quartile = (data[result.count - 1 - lower_quartile_index_1] + data[result.count - 1 - lower_quartile_index_2]) / 2;
        } else {
          lower_quartile_index_1 = ((result.count / 2) - 1) / 2;

          result.lower_quartile = data[lower_quartile_index_1];
          result.upper_quartile = data[result.count - 1 - lower_quartile_index_1];
        }
      } else {
        result.median = data[((result.count + 1) / 2) - 1];

        // odd / even
        if(is_even((result.count - 1) / 2)) {
          lower_quartile_index_1 = ((result.count - 1) / 2) / 2;
          lower_quartile_index_2 = lower_quartile_index_1 - 1;

          result.lower_quartile = (data[lower_quartile_index_1] + data[lower_quartile_index_2]) / 2;
          result.upper_quartile = (data[result.count - 1 - lower_quartile_index_1] + data[result.count - 1 - lower_quartile_index_2]) / 2;
        } else {
          lower_quartile_index_1 = (((result.count - 1) / 2) - 1) / 2;

          result.lower_quartile = data[lower_quartile_index_1];
          result.upper_quartile = data[result.count - 1 - lower_quartile_index_1];
        }
      }

      // the data is sorted so the mimimum and maximum are the first and last values
      result.minimum = data[0];
      result.maximum = data[result.count - 1];

      // the range is difference between the minimum and the maximum
      result.range = result.maximum - result.minimum;
      // and the inter-quartile range is the difference between the upper and lower quartiles
      result.inter_quartile_range = result.upper_quartile - result.lower_quartile;

      // this is the formula for the POPULATION variance
      result.variance_population = (sum_of_squares - ((Math.pow(result.total, 2)) / result.count)) / result.count;
      // the standard deviation is the square root of the variance
      result.standard_deviation_population = Math.sqrt(result.variance_population);

      // the formula for the sample variance is slightly different in that it use count -1
      result.variance_sample = (sum_of_squares - ((Math.pow(result.total, 2)) / result.count)) / (result.count - 1);
      // the sample standard deviation is the square root of the sample variance
      result.standard_deviation_sample = Math.sqrt(result.variance_sample);

      // this is Pearson's second skewness coefficient, one of many measures of skewness
      result.skew = (3.0 * (result.arithmetic_mean - result.median)) / result.standard_deviation_population;

      return result;
    },
    
    get stats() {
      const inHours = false;
      const statistics = this.statistics(Object.values(this.summary)||[]);
      const outliers = this.outliers(statistics.lower_quartile, statistics.inter_quartile_range, statistics.upper_quartile);
      const transform = function (ms) {
        if (inHours) {
          return parseFloat((ms/1000/60/60).toFixed(2));
        } else {
          return ms;
        }
      }
      console.log("statistics", statistics);

      let factor = 1.5;
      let upper_fence = statistics.maximum - (statistics.upper_quartile + (statistics.inter_quartile_range * factor));
      let lower_fence = (statistics.lower_quartile - (statistics.inter_quartile_range * factor)) - statistics.minimum;
      
      document.querySelector("article.upper.outlier").style.flexGrow = upper_fence;
      document.querySelector("article.upper.quartile").style.flexGrow = (statistics.maximum - upper_fence) - statistics.upper_quartile;
      document.querySelector("article.internal.quartile").style.flexGrow = statistics.inter_quartile_range;
      document.querySelector("article.lower.quartile").style.flexGrow = statistics.lower_quartile - lower_fence;
      document.querySelector("article.lower.outlier").style.flexGrow = lower_fence;

      // document.querySelector("ins.median").style.marginLeft = (((statistics.median-lower_fence)/statistics.maximum) * 40)/2 + "rem";
      
      return {
        records: Object.keys(this.summary).length,
        inHours: inHours,
        mean: transform(statistics.arithmetic_mean),
        median: transform(statistics.median),
        lower_quartile: transform(statistics.lower_quartile),
        upper_quartile: transform(statistics.upper_quartile), 
        inter_quartile_range: transform(statistics.inter_quartile_range),
        outliers: outliers
      }
    },
    
    get latest () {
      return this.summary;
    }
  };

  const ingest = function () {
    fetch("Simulations-500.json", { method:"GET" })
      .then(response => response.json())
      .then(data => collection.update(data))
      // .then(response => fetch(ENDPOINT+API.Stats, { method:"GET" }))
      // .then(response => response.json())
      // .then(data => collection.append(data.Stats))
      .catch(function (error) {
        console.error(error);
      })
      .finally(function () {
        console.log("Done!");
        document.querySelector("input[name=traverse]").removeAttribute("disabled");
      }
    );
  };

  const init = function () {

    let restarter = document.querySelector("input[name=restart]");
    let traverser = document.querySelector("input[name=traverse]");

    restarter.addEventListener("click", function(event) {
      if (Object.keys(collection.latest).length > 0) {
        window.location.reload();
      } else {
        ingest();
      }
    });
    traverser.addEventListener("click", function(event) {
      let output = document.querySelector("output");
      if (collection.traverse()) {
        output.innerText = JSON.stringify(collection.stats,  null, 2);
      } else {
        alert("You have them all!");
      }
    });
  };

  document.addEventListener("DOMContentLoaded", init);

</script>
</body>
</html>